#!/usr/bin/env python
import argparse
parser = argparse.ArgumentParser(description = "Plot veto efficiency")
parser.add_argument('-d','--debug', default=False, dest = 'BUG')
parser.add_argument('-r','--ranges', default='high', dest = 'RANGE')

args = parser.parse_args()

from icecube import icetray, dataclasses, dataio
from icecube import phys_services, simclasses, MuonGun
from I3Tray import I3Tray
from icecube.icetray import I3Units
from icecube.MuonGun import load_model, StaticSurfaceInjector, Cylinder, OffsetPowerLaw, BundleConfiguration, BundleEntry

import matplotlib
from matplotlib import rc
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import numpy as np
from scipy.optimize import curve_fit

def sigmoid(x, k0, x0, c):
     y = (1-c) / (1 + np.exp(-k0*(np.log10(x)-x0)))+c
     return y
def sigmoid_gauss(x,k0, x0, k1, x1, b, c):
     y = (1-b) / (1 + np.exp(-k0*(np.log10(x)-x0)))+c*np.exp(-(np.log10(x)-x1)**2/k1)
     return y

def take_ratios(numerator, denominator):
    ratio = list()
    for i in range(len(numerator)):
        if (denominator[i] == 0): n_ratio = 0
        else: n_ratio = numerator[i]/ denominator[i]
        ratio.append(n_ratio)
    return ratio

#load a long list of files
file_name = 'file_list.txt'
file_list = open(file_name).read().splitlines()
infile    = dataio.I3FrameSequence(file_list)
normalization  = len(file_list)
print "loaded your MC in " + str(normalization) +" files!"

#initialize values
muon_1 = [];
muon_1.append([]);#[0] energy
muon_1.append([]);#[1] z position
muon_1.append([]);#[2] all weights
muon_1.append([]);#[3] passes PE >3 veto
muon_2 = [];
muon_2.append([]);#[0] energy
muon_2.append([]);#[1] z position
muon_2.append([]);#[2] all weights
muon_2.append([]);#[3] passes PE >3 veto
muon = [];
muon.append([]);#[0] energy
muon.append([]);#[1] z position
muon.append([]);#[2] all weights
muon.append([]);#[3] passes PE >3 veto

#initialize the loop 
event_count = 1
for frame in infile:
     if(event_count%100000 == 0): 
          print "Event: "+ str(event_count); 
          if(args.BUG): break;
     if ("HLCInIcePulses" not in frame): continue; #only care about pframes 
     event_count += 1; number_muons = 0;
     for particle in frame["I3MCTree"]:
          if particle.type == dataclasses.I3Particle.ParticleType.MuMinus:
               number_muons += 1; #found number of true muons
     if ("EnteringMuon_0" in frame) and ("EnteringMuon_1" not in frame): #count all events with exactly n = 1 muons
          veto = 0; leading_muon = frame["EnteringMuon_0"];
          energy = leading_muon.energy; zpos = leading_muon.pos.z;
          weight = frame["MuonWeight"].value/normalization #normalized by total files
          if("VHESelfVeto_3Clean" in frame):  veto  = (int(frame["VHESelfVeto_3Clean"].value) ) * weight;
          muon[0].append(energy); muon[1].append(zpos); muon[2].append(weight); muon[3].append(veto);
     if ("EnteringMuon_0" in frame): #count all events with exactly n = 2 muons
          leader_pos = 0; 
          veto_1  = 0; veto_2  = 0; 
          if(frame["EnteringMuon_1"].energy > frame["EnteringMuon_0"].energy): leader_pos = 1;
          leading_muon    = frame["EnteringMuon_"+str(leader_pos)]
          subleading_muon = frame["EnteringMuon_"+str(int(not leader_pos))]
          energy_1 = leading_muon.energy; zpos_1 = leading_muon.pos.z; 
          weight_1 = frame["MuonWeight"].value/normalization #normalized by total files
          energy_2 = subleading_muon.energy; zpos_2 = subleading_muon.pos.z;
          weight_2 = frame["MuonWeight"].value/normalization #normalized by total files
          if("VHESelfVeto_3Clean" in frame):  veto_1  = (int(frame["VHESelfVeto_3Clean"].value) ) * weight_1;
          if("VHESelfVeto_3Clean" in frame):  veto_2  = (int(frame["VHESelfVeto_3Clean"].value) ) * weight_2;
          muon_1[0].append(energy_1); muon_1[1].append(zpos_1); muon_1[2].append(weight_1); muon_1[3].append(veto_1);
          muon_2[0].append(energy_2); muon_2[1].append(zpos_2); muon_2[2].append(weight_2); muon_2[3].append(veto_2); 
          
print "Processed " +str(event_count)+ " events generated by you!"
muon_1_plus_2 = np.add(muon_1[0], muon_2[0]);

xbins= 50
xmin = 1e1; xmax = 1e5; 
if(args.RANGE == "high"): xmin = 1e2;
xbins = np.logspace(np.log10(xmin),np.log10(xmax), xbins)
weight_vals_1, edges_1   = np.histogram(muon_1[0], weights=muon_1[2], bins=xbins, range=(xmin,xmax))
veto_vals_1, _           = np.histogram(muon_1[0], weights=muon_1[3], bins=xbins, range=(xmin,xmax))
acceptance_1  = np.divide(veto_vals_1, weight_vals_1, out=np.zeros_like(veto_vals_1), where=weight_vals_1!=0)
weight_vals_12, edges_12 = np.histogram(muon_1_plus_2, weights=muon_1[2], bins=xbins, range=(xmin,xmax))
veto_vals_12, _          = np.histogram(muon_1_plus_2, weights=muon_1[3], bins=xbins, range=(xmin,xmax))
acceptance_12  = np.divide(veto_vals_12, weight_vals_12, out=np.zeros_like(veto_vals_12), where=weight_vals_12!=0)
weight_vals, edges   = np.histogram(muon[0], weights=muon[2], bins=xbins, range=(xmin,xmax))
veto_vals, _           = np.histogram(muon[0], weights=muon[3], bins=xbins, range=(xmin,xmax))
acceptance  = np.divide(veto_vals, weight_vals, out=np.zeros_like(veto_vals), where=weight_vals!=0)
xvals   = edges[:-1]

#do fit
x = np.logspace(np.log10(xmin),np.log10(xmax), len(xbins)*10)
popt_1, pcov_1  = curve_fit(sigmoid, xvals, acceptance_1, maxfev=10000)
y_1  = sigmoid(x, *popt_1)
popt_12, pcov_12  = curve_fit(sigmoid, xvals, acceptance_12, maxfev=10000)
y_12  = sigmoid(x, *popt_12)
popt, pcov  = curve_fit(sigmoid, xvals, acceptance, maxfev=10000)
y  = sigmoid(x, *popt)

#do plotting
f, (ax1, ax2) = plt.subplots(2, 1, sharex=True, gridspec_kw = {'height_ratios':[2, 1]})

ax1.semilogx(xvals, acceptance_1,  label='leading muon, N = 2',  ls='-', color='r')
ax1.semilogx(x,y_1,  ls='--', color='r')
ax1.semilogx(xvals, acceptance_12,  label='1st+2nd muon, N = 2',  ls='-', color='g')
ax1.semilogx(x,y_12,  ls='--', color='g')
ax1.semilogx(xvals, acceptance,  label='single muons',  ls='-', color='b')
ax1.semilogx(x,y,  ls='--', color='b')

ax2.semilogx(x,np.divide(y_1,y),  ls='-', color='r')
ax2.semilogx(x,np.divide(y_12,y),  ls='-', color='g')

#labels
matplotlib.rcParams.update({'font.size': 14})
ax1.legend(loc='lower right')
ax1.set_ylabel('P$_{light}$')
ax1.grid(linestyle=':', linewidth=0.5)
ax1.set_ylim(0.0, 1.1)
ax1.yaxis.set_ticks(np.arange(0, 1.1, 0.1))

ax2.set_xlabel("E$_{\mu}$ [GeV]")
ax2.set_ylabel(r'$\frac{N = 2 Dists}{Single Muons}$')
ax2.grid(linestyle=':', linewidth=0.5)
ax2.set_ylim(0.4, 1.6)
ax2.yaxis.set_ticks(np.arange(0.4, 1.6, 0.2))

#plt.show()
plt.savefig("energy_dist_n1_vs_n2_only_one_required_to_enter_"+args.RANGE+"_fitrange.pdf")
print "Made file: " + "energy_dist_n1_vs_n2_only_one_required_to_enter_"+args.RANGE+"_fitrange.pdf"
